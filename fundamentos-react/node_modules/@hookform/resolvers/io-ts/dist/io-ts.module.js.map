{"version":3,"file":"io-ts.module.js","sources":["../src/arrayToPath.ts","../src/errorsToRecord.ts","../src/io-ts.ts"],"sourcesContent":["import * as Either from 'fp-ts/Either';\nimport { pipe } from 'fp-ts/function';\n\nconst arrayToPath = (paths: Either.Either<string, number>[]): string =>\n  paths.reduce(\n    (previous, path, index) =>\n      pipe(\n        path,\n        Either.fold(\n          (key) => `${index > 0 ? '.' : ''}${key}`,\n          (key) => `[${key}]`,\n        ),\n        (path) => `${previous}${path}`,\n      ),\n    '',\n  );\n\nexport default arrayToPath;\n","import * as t from 'io-ts';\nimport {\n  IntersectionType,\n  TaggedUnionType,\n  UnionType,\n  ValidationError,\n} from 'io-ts';\nimport { absurd, flow, identity, not, pipe } from 'fp-ts/function';\nimport * as ReadonlyArray from 'fp-ts/ReadonlyArray';\nimport * as Option from 'fp-ts/Option';\nimport * as Either from 'fp-ts/Either';\nimport * as SemiGroup from 'fp-ts/Semigroup';\nimport arrayToPath from './arrayToPath';\nimport * as ReadonlyRecord from 'fp-ts/ReadonlyRecord';\nimport { ErrorObject, FieldErrorWithPath } from './types';\n\nconst formatErrorPath = (context: t.Context): string =>\n  pipe(\n    context,\n    ReadonlyArray.filterMapWithIndex((index, contextEntry) => {\n      const previousIndex = index - 1;\n\n      const shouldBeFiltered =\n        context[previousIndex] === undefined ||\n        context[previousIndex].type instanceof TaggedUnionType ||\n        context[previousIndex].type instanceof UnionType ||\n        context[previousIndex].type instanceof IntersectionType;\n\n      return shouldBeFiltered ? Option.none : Option.some(contextEntry);\n    }),\n    ReadonlyArray.map(({ key }) => key),\n    ReadonlyArray.map((key) =>\n      pipe(\n        key,\n        (k) => parseInt(k, 10),\n        Either.fromPredicate(not<number>(Number.isNaN), () => key),\n      ),\n    ),\n    ReadonlyArray.toArray,\n    arrayToPath,\n  );\n\nconst formatError = (e: t.ValidationError): FieldErrorWithPath => {\n  const path = formatErrorPath(e.context);\n\n  const message = pipe(\n    e.message,\n    Either.fromNullable(e.context),\n    Either.mapLeft(\n      flow(\n        ReadonlyArray.last,\n        Option.map(\n          (contextEntry) =>\n            `expected ${contextEntry.type.name} but got ${JSON.stringify(\n              contextEntry.actual,\n            )}`,\n        ),\n        Option.getOrElseW(() =>\n          absurd<string>('Error context is missing name' as never),\n        ),\n      ),\n    ),\n    Either.getOrElseW(identity),\n  );\n\n  const type = pipe(\n    e.context,\n    ReadonlyArray.last,\n    Option.map((contextEntry) => contextEntry.type.name),\n    Option.getOrElse(() => 'unknown'),\n  );\n\n  return { message, type, path };\n};\n\n// this is almost the same function like Semigroup.getObjectSemigroup but reversed\n// in order to get the first error\nconst getObjectSemigroup = <\n  A extends Record<string, unknown> = never,\n>(): SemiGroup.Semigroup<A> => ({\n  concat: (first, second) => Object.assign({}, second, first),\n});\n\nconst concatToSingleError = (\n  errors: ReadonlyArray<FieldErrorWithPath>,\n): ErrorObject =>\n  pipe(\n    errors,\n    ReadonlyArray.map((error) => ({\n      [error.path]: {\n        type: error.type,\n        message: error.message,\n      },\n    })),\n    (errors) => SemiGroup.fold(getObjectSemigroup<ErrorObject>())({}, errors),\n  );\n\nconst appendSeveralErrors: SemiGroup.Semigroup<FieldErrorWithPath> = {\n  concat: (a, b) => ({\n    ...b,\n    types: { ...a.types, [a.type]: a.message, [b.type]: b.message },\n  }),\n};\n\nconst concatToMultipleErrors = (\n  errors: ReadonlyArray<FieldErrorWithPath>,\n): ErrorObject =>\n  pipe(\n    ReadonlyRecord.fromFoldableMap(appendSeveralErrors, ReadonlyArray.Foldable)(\n      errors,\n      (error) => [error.path, error],\n    ),\n    ReadonlyRecord.map((errorWithPath) => {\n      // eslint-disable-next-line @typescript-eslint/no-unused-vars\n      const { path, ...error } = errorWithPath;\n\n      return error;\n    }),\n  );\n\nconst errorsToRecord =\n  (validateAllFieldCriteria: boolean) =>\n  (validationErrors: ReadonlyArray<ValidationError>): ErrorObject => {\n    const concat = validateAllFieldCriteria\n      ? concatToMultipleErrors\n      : concatToSingleError;\n\n    return pipe(validationErrors, ReadonlyArray.map(formatError), concat);\n  };\n\nexport default errorsToRecord;\n","import * as Either from 'fp-ts/lib/Either';\nimport { pipe } from 'fp-ts/function';\nimport { toNestError } from '@hookform/resolvers';\nimport errorsToRecord from './errorsToRecord';\nimport { Resolver } from './types';\n\nexport const ioTsResolver: Resolver = (codec) => (values, _context, options) =>\n  pipe(\n    values,\n    codec.decode,\n    Either.mapLeft(errorsToRecord(options.criteriaMode === 'all')),\n    Either.mapLeft((errors) => toNestError(errors, options.fields)),\n    Either.fold(\n      (errors) => ({\n        values: {},\n        errors,\n      }),\n      (values) => ({\n        values,\n        errors: {},\n      }),\n    ),\n  );\n"],"names":["arrayToPath","paths","reduce","previous","path","index","pipe","Either","key","formatError","e","context","ReadonlyArray","contextEntry","previousIndex","undefined","type","TaggedUnionType","UnionType","IntersectionType","Option","k","parseInt","not","Number","isNaN","message","flow","name","JSON","stringify","actual","absurd","identity","concatToSingleError","errors","error","SemiGroup","concat","first","second","Object","assign","appendSeveralErrors","a","b","types","concatToMultipleErrors","ReadonlyRecord","errorWithPath","ioTsResolver","codec","values","_context","options","decode","validateAllFieldCriteria","criteriaMode","validationErrors","toNestError","fields"],"mappings":"g2BAGA,IAAMA,EAAc,SAACC,UACnBA,EAAMC,OACJ,SAACC,EAAUC,EAAMC,UACfC,EACEF,EACAG,EACE,SAACC,UAAWH,EAAQ,EAAI,IAAM,IAAKG,GACnC,SAACA,aAAYA,QAEf,SAACJ,YAAYD,EAAWC,KAE5B,KC4BEK,EAAc,SAACC,GACnB,IA3BuBC,EA2BjBP,EA1BNE,EADuBK,EA2BMD,EAAEC,QAxB7BC,EAAiC,SAACP,EAAOQ,GACvC,IAAMC,EAAgBT,EAAQ,EAQ9B,YAL6BU,IAA3BJ,EAAQG,IACRH,EAAQG,GAAeE,gBAAgBC,GACvCN,EAAQG,GAAeE,gBAAgBE,GACvCP,EAAQG,GAAeE,gBAAgBG,EAEfC,EAAcA,EAAYP,KAEtDD,EAAkB,qBAAGJ,MACrBI,EAAkB,SAACJ,UACjBF,EACEE,EACA,SAACa,UAAMC,SAASD,EAAG,KACnBd,EAAqBgB,EAAYC,OAAOC,OAAQ,kBAAMjB,OAG1DI,EACAZ,GAiCF,MAAO,CAAE0B,QA3BOpB,EACdI,EAAEgB,QACFnB,EAAoBG,EAAEC,SACtBJ,EACEoB,EACEf,EACAQ,EACE,SAACP,qBACaA,EAAaG,KAAKY,iBAAgBC,KAAKC,UACjDjB,EAAakB,UAGnBX,EAAkB,kBAChBY,EAAe,qCAIrBzB,EAAkB0B,IAUFjB,KAPLV,EACXI,EAAEC,QACFC,EACAQ,EAAW,SAACP,UAAiBA,EAAaG,KAAKY,OAC/CR,EAAiB,iBAAM,aAGDhB,KAAAA,IAWpB8B,EAAsB,SAC1BC,UAEA7B,EACE6B,EACAvB,EAAkB,SAACwB,sBAChBA,EAAMhC,MAAO,CACZY,KAAMoB,EAAMpB,KACZU,QAASU,EAAMV,aAGnB,SAACS,UAAWE,EAfgB,CAC9BC,OAAQ,SAACC,EAAOC,UAAWC,OAAOC,OAAO,GAAIF,EAAQD,KAcvCF,CAAkD,GAAIF,MAGhEQ,EAA+D,CACnEL,OAAQ,SAACM,EAAGC,qBACPA,GACHC,WAAYF,EAAEE,cAAQF,EAAE5B,MAAO4B,EAAElB,UAAUmB,EAAE7B,MAAO6B,EAAEnB,gBAIpDqB,EAAyB,SAC7BZ,UAEA7B,EACE0C,EAA+BL,EAAqB/B,EAApDoC,CACEb,EACA,SAACC,SAAU,CAACA,EAAMhC,KAAMgC,KAE1BY,EAAmB,SAACC,GAIlB,0IAF2BA,gBC5GpBC,EAAyB,SAACC,mBAAWC,EAAQC,EAAUC,UAClEhD,EACE8C,EACAD,EAAMI,OACNhD,GD+GDiD,EC/GwD,QAAzBF,EAAQG,sBDgHvCC,GACC,IAAMpB,EAASkB,EACXT,EACAb,EAEJ,OAAO5B,EAAKoD,EAAkB9C,EAAkBH,GAAc6B,MCpH9D/B,EAAe,SAAC4B,UAAWwB,EAAYxB,EAAQmB,EAAQM,UACvDrD,EACE,SAAC4B,SAAY,CACXiB,OAAQ,GACRjB,OAAAA,IAEF,SAACiB,SAAY,CACXA,OAAAA,EACAjB,OAAQ,ODsGd,IAACqB"}